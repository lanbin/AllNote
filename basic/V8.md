V8将JavaScript直接翻译成机器代码而不是

> 源代码 => 字节码 => 机器代码



字节码的存在应该是因为当初虚拟机需要在不同平台进行运行，不同平台的机器指令又不尽相同，所以源代码会被编译成成一个字节码文件，再交由不同平台的虚拟机去转成机器代码从而达到一份代码在不同平台都可以运行的目的。

## 位

bit： 一个位长有两个可能的值： 1 or 0

用于对于芯片电路的高低电平。

## 字节

byte：一个字节拥有8位，那么每一个字节则拥有256个可能的代码值。

2^8^ = 256

那么200多个指令就可以被包含到一个字节上。

----

### Javascript属性搜索的成本

相对于Javascript这种解释型语言（程序不需要编译，在运行时才翻译成机器语言，每执行一次都要翻译一次）

C那些编译型语言（直接编译成机器语言）

还有Java这种（先编译成字节码，再通过虚拟机翻译成本地的机器码）的编译解释型语言。

在强类型中，一个Hash表中的属性和对象，由于类型是固定的，所以属性值或者属性的指针可以在连续缓冲区存储在存储中，每个缓冲区拥有固定的偏移量，可以根据属性类型轻松确定偏移量。

而Javascript可以在运行时随意修改属性，所以无法按照上面这种方式存储，所以查找起来更费劲，消耗更大。

为了解决这个问题，V8使用了**隐藏类**。

当若干个实例被创建之后，这些实例被描述成一个隐藏类。

如果实例在创建之后没有动态的添加属性，那么隐藏类不会进行分裂。

如果一个实例增加了新的属性，隐藏类会分裂出来一个新的隐藏类来描述增加了新属性的实例。

如果几个实例都增加了几个相同的新属性，但是顺序不同，那么就会造成隐藏类分别分裂给到几个实例。

**所以，如果要增加动态属性，最好顺序一直保证隐藏类不会分裂太多，可以重用。**

